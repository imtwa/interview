# 北京 掌上先机 一面 2024-07-25 50min

## 1 当时选框架为什么选vue

## 2 什么是MVC和MVVM

​	MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化开发效率。

​	 在开发单页面应用时，往往一个路由页面对应了一个脚本文件，所有 的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时， 可能看不出什么问题，如果项目变得复杂，那么整个文件就会变得冗长、混乱，这样对项目开发和后期的项目维护是非常不利的。 

### （1）MVC 

​	MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。 其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据， 以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。 

### （2）MVVM 

​	MVVM 分为 Model、View、ViewModel： Model 代表数据模型，数据和业务逻辑都在 Model 层中定义； View 代表 UI 视图，负责数据的展示； ViewModel 负责监听 Model 中数据的改变并且控制视图的更新，处理用户交互操作； Model 和 View 并无直接关联，而是通过 ViewModel 来进行联系的， Model 和 ViewModel 之间有着双向数据绑定的联系。因此当 Model 中 的数据改变时会触发 View 层的刷新，View 中由于用户交互操作而改变的数据也会在 Model 中同步。 这种模式实现了 Model 和 View 的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作 DOM。

### （3）MVP 

​	MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中使用观察者模式，来实现当 Model 层数据发生变化的时 候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对 代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的 Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦， Presenter 还包含了其他的响应逻辑。

## 3 vue怎么实现数据改变视图也改变

Vue.js 实现数据改变视图也改变的核心原理是响应式系统（Reactive System）。Vue 使用了一个基于 ES6 的 `Object.defineProperty` 方法（在 Vue 3 中，使用了更高效的 Proxy 对象）来拦截对象属性的 getter 和 setter，从而实现了数据变化时视图的自动更新。

### Vue 2.x 的实现方式

在 Vue 2.x 中，当 Vue 实例被创建时，Vue 会遍历 data 中的所有属性，并使用 `Object.defineProperty` 将它们转换为 getter/setter。这样，Vue 就能追踪到数据的变化，并在数据变化时通知视图进行更新。

1. **创建 Vue 实例**：在 Vue 实例中定义 `data`，Vue 会将 `data` 对象的属性转换为 getter/setter。

```javascript
new Vue({  
  el: '#app',  
  data: {  
    message: 'Hello Vue!'  
  }  
});
```

1. **模板渲染**：在模板中绑定数据，如使用双大括号 `{{ message }}` 或 `v-bind`、`v-model` 等指令。

```html
<div id="app">  
  {{ message }}  
</div>
```

1. **数据变化**：当 `data` 中的 `message` 发生变化时，Vue 检测到 setter 被调用，并通知视图进行更新。

```javascript
// 假设这是 Vue 实例的某个方法或事件处理函数  
this.message = 'Hello, Vue.js!';
```

### Vue 3.x 的实现方式

Vue 3.x 引入了 Composition API 和 Proxy 对象，以更现代和灵活的方式实现响应式系统。Proxy 提供了比 `Object.defineProperty` 更全面的拦截能力，包括对象属性的添加、删除等。

1. **创建响应式对象**：使用 Vue 3 的 `reactive` 函数或 `ref` 函数来创建响应式对象或响应式引用。

```javascript
import { reactive, ref } from 'vue';  
  
const state = reactive({  
  message: 'Hello Vue 3!'  
});  
  
const message = ref('Hello Vue 3!');
```

1. **模板渲染**：Vue 3 的模板语法与 Vue 2 类似，但可以使用 Composition API 中的 `setup` 函数来组织逻辑。

```html
<template>  
  <div>  
    {{ state.message }}  
    {{ message.value }}  
  </div>  
</template>  
  
<script>  
import { reactive, ref } from 'vue';  
  
export default {  
  setup() {  
    const state = reactive({  
      message: 'Hello Vue 3!'  
    });  
  
    const message = ref('Hello Vue 3!');  
  
    return { state, message };  
  }  
}  
</script>
```

1. **数据变化**：当 `state.message` 或 `message.value` 发生变化时，Vue 3 通过 Proxy 拦截到这些变化，并自动更新视图。

```javascript
// 假设在 setup 函数或某个方法中  
state.message = 'Updated message!';  
message.value = 'Updated ref!';
```

## 4 vue用的什么方法通知视图

Vue使用了一套响应式系统来通知视图更新，这个系统的核心原理主要基于以下几个方法和技术：

### 1. 依赖追踪

在Vue中，当数据对象被定义在组件的`data`函数中时，Vue会遍历这些属性，并使用`Object.defineProperty`（Vue 2.x）或`Proxy`（Vue 3.x）来将它们转换为getter/setter。这样做的目的是为了追踪哪些属性被组件的模板或其他计算属性/侦听器所依赖。

- **Vue 2.x**：使用`Object.defineProperty`在属性上设置getter和setter。当属性被访问时，getter会被调用，此时Vue可以收集依赖（例如，正在渲染的模板或计算属性）。当属性值被修改时，setter会被调用，此时Vue可以通知这些依赖进行更新。
- **Vue 3.x**：使用`Proxy`对象来拦截对象属性的读取和设置操作。与`Object.defineProperty`相比，`Proxy`提供了更全面的拦截能力，包括属性的添加、删除等。

### 2. 虚拟DOM与DOM Diff算法

Vue使用虚拟DOM来优化DOM操作。当数据变化时，Vue会重新渲染组件的虚拟DOM树，并与旧的虚拟DOM树进行比较（使用DOM Diff算法）。这个比较过程会高效地计算出需要更新的真实DOM部分，并只对这些部分进行实际的DOM操作。

### 3. 组件更新

Vue的组件系统也是视图更新的重要部分。当组件的数据变化时，Vue会重新渲染该组件的模板，并递归地更新其子组件。这个过程是自动的，开发者不需要手动操作DOM。

### 4. 强制更新

虽然Vue的响应式系统会自动处理大部分数据变化并通知视图更新，但在某些特殊情况下，开发者可能需要手动触发视图的更新。Vue提供了`$forceUpdate`方法，可以强制组件重新渲染。但需要注意的是，这个方法应该谨慎使用，因为它会跳过Vue的响应式系统，直接进行DOM操作，这可能会导致性能问题或状态不一致的问题。

### 5. 数组与对象的方法

对于数组和对象，Vue提供了一些特殊的方法来确保它们的变化能够被响应式系统检测到。例如，Vue 2.x中，对于数组，Vue重写了`push`、`pop`、`shift`、`unshift`、`splice`、`sort`、`reverse`等方法，以确保使用这些方法修改数组时能够触发视图更新。对于对象，Vue提供了`Vue.set`（Vue 2.x）或`this.$set`（在组件内部）方法来确保新添加的属性也是响应式的。在Vue 3.x中，由于使用了`Proxy`，这些限制得到了缓解，但使用Vue提供的方法仍然是一个好习惯。

## 5 拷打项目 web怎么实现的代理转发请求

- **原理**：Vue CLI通过配置反向代理服务器，将前端的请求转发到后端服务器，从而绕过浏览器的同源策略限制。当Vue CLI的开发服务器接收到前端发起的跨域请求时，它不会直接将该请求发送到真正的后端服务器，而是先将其转发到配置好的代理服务器上。代理服务器再将请求转发到实际的后端服务器，并将响应返回给前端。
- **配置方式**：在Vue CLI项目中，通常通过修改`vue.config.js`文件来配置反向代理。在该文件中，可以定义一系列的代理规则，指定哪些请求应该被转发到哪个后端服务器。

## 6 为什么会有跨域

跨域问题产生的原因主要源于浏览器的同源策略（Same-Origin Policy），这是浏览器的一种安全机制。同源策略是一种约定，它限制了来自不同源的文档或脚本之间如何相互作用，以保护用户信息安全，防止恶意网站窃取数据。

### 同源策略的定义

所谓“同源”指的是两个页面具有相同的协议（protocol）、主机（host）和端口（port）。三者中只要有一个不相同，就会产生跨域问题。例如，`http://www.example.com`和`https://www.example.com`由于协议不同，被视为不同源；`http://www.example.com`和`http://sub.example.com`由于主机不同，也被视为不同源；`http://www.example.com`和`http://www.example.com:8080`由于端口不同，同样被视为不同源。

### 跨域问题的产生

当浏览器尝试从一个源（origin）加载并执行一个来自不同源的脚本时，浏览器的同源策略会阻止这种行为。这是因为跨域请求可能会带来安全风险，比如：

- 恶意网站可能通过跨域请求窃取用户数据。
- 跨域请求可能用于进行CSRF（跨站请求伪造）攻击。

因此，浏览器默认禁止跨域请求，以确保用户的信息安全。

### 跨域问题的常见场景

1. **AJAX请求**：当JavaScript发起AJAX请求时，如果请求的URL与当前页面的URL不同源，浏览器会阻止这个请求，导致跨域问题。
2. **Cookie和LocalStorage**：由于同源策略的限制，不同源的页面不能共享Cookie和LocalStorage等存储性内容。
3. **DOM操作**：JavaScript的DOM操作也受到同源策略的限制，不能跨域操作其他源的DOM。

## 7 解决跨域的方法

### 一、前端解决方案

1. JSONP（JSON with Padding）
   - **原理**：利用`<script>`标签不受同源策略限制的特性，通过动态创建`<script>`标签并设置其`src`属性来请求跨域资源。服务端返回的是一个调用函数的字符串，而不是纯JSON数据。
   - **限制**：只能实现GET请求，不支持POST请求以及大数据量的请求，也无法获取返回头、状态码等数据。此外，callback参数恶意注入可能会造成XSS漏洞。
2. CORS（Cross-Origin Resource Sharing）
   - **原理**：CORS是一个W3C标准，允许浏览器向跨域服务器发送请求，通过服务器设置响应头`Access-Control-Allow-Origin`来允许特定的外部域访问资源。
   - **支持情况**：目前主流浏览器（IE10及以上）都支持CORS，但IE8和IE9需要使用`XDomainRequest`对象进行兼容，IE7及以下浏览器不支持。
   - **优势**：支持所有类型的HTTP请求，功能完善，通过`Access-Control-Allow-Origin`进行资源访问授权。
3. postMessage
   - **原理**：允许不同源的iframe之间安全地传递消息。使用`window.postMessage`方法发送消息，并通过监听`message`事件来接收消息。
   - **优势**：安全性高，可以通过检查消息来源来确保消息的安全性。

### 二、后端解决方案

1. 设置响应头
   - 后端服务器可以设置`Access-Control-Allow-Origin`等CORS相关的响应头来允许跨域请求。
   - 例如，在Node.js中，可以使用`express`框架的`cors`中间件来轻松设置CORS。
2. 代理服务器
   - 在客户端和服务器之间设置一个代理服务器，客户端的请求首先发送到代理服务器，代理服务器再转发到目标服务器，然后将响应返回给客户端。
   - 常用的代理服务器软件有Nginx、Apache等。
   - 例如，在Nginx中，可以通过配置反向代理来实现跨域请求。

### 三、其他解决方案

1. document.domain + iframe
   - 适用于两个不同域但同主域的页面，例如`example.com`和`sub.example.com`。通过设置`document.domain`为相同的主域来绕过同源策略。
2. location.hash + iframe
   - 利用iframe的`location.hash`传值来实现跨域通信。这种方法主要利用URL的hash值在不同页面之间共享的特性。
3. WebSocket
   - WebSocket协议允许开启一个全双工通信会话，可以在不受同源策略限制的情况下进行数据交换。

## 8 怎么实现虚拟列表

虚拟列表（Virtual List）是一种优化长列表显示的技术，特别是在Web和移动应用中，当列表数据非常多时，直接渲染整个列表会导致性能问题，如滚动不流畅、页面卡顿等。虚拟列表通过只渲染可视区域内的列表项，并在滚动时动态更新渲染的列表项，从而显著提高性能和用户体验。

以下是实现虚拟列表的基本步骤和技术要点：

### 1. 确定可视区域

首先，需要知道哪些列表项是当前在视口（viewport）中的。这通常涉及到计算滚动位置、列表项的高度以及视口的高度。

### 2. 计算渲染范围

基于滚动位置和视口大小，可以计算出哪些列表项（或列表项的一部分）应该被渲染。这通常意味着你只会渲染当前滚动位置上方和下方一定数量的列表项。

### 3. 动态渲染

当滚动事件发生时，需要重新计算应该渲染哪些列表项，并动态地更新DOM。这通常涉及到移除不再在视口中的列表项，并添加新的列表项。

### 4. 滚动优化

由于滚动事件可以非常频繁地触发，需要对滚动事件的处理进行优化。常见的方法包括防抖（debounce）和节流（throttle）技术，以减少滚动事件的处理频率。

### 5. 回收和复用DOM节点

为了提高性能，可以尝试复用DOM节点，而不是在每次滚动时都创建和销毁它们。这通常涉及到使用文档片段（DocumentFragment）或虚拟DOM库来管理DOM的更新。

### 6. 使用现成的库

如果不想从头开始实现虚拟列表，可以使用一些现成的库，如`react-window`（针对React）、`react-virtualized`（也针对React）、`vue-virtual-scroll-list`（针对Vue）等。这些库已经为你处理了大部分复杂性，并提供了易于使用的API。

### 示例代码（概念性）

这里提供一个非常简化的概念性示例，说明如何在JavaScript中手动实现虚拟列表的基本逻辑：

```javascript
// 假设有一个长列表和一个容器元素  
const listItems = [...Array(10000).keys()]; // 假设有10000个列表项  
const container = document.getElementById('list-container');  
  
// 监听滚动事件  
container.addEventListener('scroll', function() {  
  const scrollTop = container.scrollTop; // 当前滚动位置  
  const visibleHeight = container.clientHeight; // 容器可视高度  
  const itemHeight = 50; // 假设每个列表项的高度为50px  
  
  // 计算应该渲染的第一个和最后一个列表项的索引  
  const startIndex = Math.floor(scrollTop / itemHeight);  
  const endIndex = Math.min(startIndex + Math.ceil(visibleHeight / itemHeight), listItems.length - 1);  
  
  // 渲染列表项（这里只是概念性代码，实际实现会更复杂）  
  // ...  
  
  // 注意：这里需要清除之前渲染的列表项，并添加新的列表项  
  // 这部分代码取决于你的DOM管理策略，可能是直接操作DOM，也可能是使用虚拟DOM库  
});
```

请注意，上面的代码只是一个非常简化的示例，用于说明虚拟列表的基本概念。在实际应用中，实现虚拟列表会涉及到更多的细节和性能优化。

## 9 虚拟列表内列表不同高怎么办

当虚拟列表中的列表项（items）具有不同高度时，处理起来会稍微复杂一些，因为需要动态地计算每个列表项的高度，并根据这些高度来确定哪些列表项应该被渲染在可视区域内。以下是一些处理不同高度列表项的虚拟列表的关键步骤：

### 1. 预先计算或动态计算列表项高度

- **预先计算**：如果列表项的高度是固定的或者可以根据某些规则预先计算出来（例如，基于内容类型或样式），那么可以在渲染之前先计算出所有列表项的高度，并存储在一个数组中。
- **动态计算**：如果列表项的高度是动态变化的（例如，包含不同长度的文本或图片），可能需要在列表项首次渲染到DOM时计算其高度，并缓存这个值以便后续使用。

### 2. 使用缓存来存储高度信息

无论是预先计算还是动态计算列表项的高度，都应该将这些高度信息存储在缓存中（例如，一个JavaScript对象或Map），以便在需要时快速检索。

### 3. 调整渲染逻辑以考虑不同高度

在渲染虚拟列表时，需要根据缓存中的高度信息来计算哪些列表项应该被渲染。这通常涉及到累加每个列表项的高度，直到累加的高度超过或接近可视区域的高度。

### 4. 滚动时更新渲染的列表项

当用户滚动列表时，需要重新计算哪些列表项现在应该被渲染。这通常涉及到更新“开始索引”和“结束索引”，这两个索引标识了当前应该渲染的列表项的范围。

### 5. 优化性能

- **避免不必要的渲染**：只渲染当前可视区域内的列表项，并在滚动时动态更新这些列表项。
- **使用节流或防抖**：对滚动事件进行节流或防抖处理，以减少滚动时计算量和DOM更新的频率。
- **复用DOM节点**：尝试复用已经渲染的DOM节点，而不是在每次滚动时都销毁和重新创建它们。

### 6. 考虑使用现成的库

由于实现一个处理不同高度列表项的虚拟列表可能会相当复杂，因此使用现成的库（如`react-window`、`react-virtualized`、`vue-virtual-scroller`等）可能是一个更好的选择。这些库通常已经内置了对不同高度列表项的支持，并提供了易于使用的API。

## 10 了解promise吗

Promise 是 JavaScript 中一个非常重要的概念，用于处理异步操作。Promise 代表了一个尚未完成但预期将来会完成的操作的最终结果。它允许你将异步操作的成功值或失败原因与它们各自的处理程序关联起来。这种方式可以更加优雅地处理异步操作，避免了传统的回调地狱（Callback Hell）问题。

### Promise 的基本状态

Promise 有三种状态：

1. **Pending（等待态）**：初始状态，既不是成功，也不是失败状态。
2. **Fulfilled（成功态）**：意味着操作成功完成。
3. **Rejected（失败态）**：意味着操作失败。

### Promise 的基本用法

Promise 构造函数接受一个执行器（executor）函数作为参数，执行器函数本身又接受两个函数作为参数：

- **resolve(value)**：当异步操作成功时调用，并将异步操作的结果，作为参数传递出去。
- **reject(reason)**：当异步操作失败时调用，并将错误的信息，作为参数传递出去。

### Promise 的链式调用

Promise 提供了 `.then()` 和 `.catch()` 方法，允许链式地处理 Promise 的成功值和错误。`.then()` 方法接受两个可选参数，第一个是处理成功的函数，第二个是处理错误的函数（可选，错误可以传递到链的下一个 `.catch()`）。`.catch()` 方法用于捕获在 Promise 链中发生的错误。

### Promise 的其他方法

- **Promise.all()**：接收一个 Promise 数组作为参数，当这个数组里的所有 Promise 都变为 fulfilled 时，Promise.all 返回一个新的 Promise 实例，其解析结果是一个包含所有 Promise 解析值的数组。
- **Promise.race()**：接收一个 Promise 数组作为参数，返回一个新的 Promise 实例，这个实例将会以数组中“跑得最快”的那个 Promise 的结果作为其解析结果。
- **Promise.resolve(value)**：返回一个以给定值解析后的 Promise 对象。如果该值是一个 Promise 对象，则返回原对象；否则，返回一个新的、以给定值解析后的 Promise 对象。
- **Promise.reject(reason)**：返回一个以给定原因拒绝的 Promise 对象。

### 示例

```javascript
function fetchData() {  
  return new Promise((resolve, reject) => {  
    setTimeout(() => {  
      const success = Math.random() > 0.5;  
      if (success) {  
        resolve('数据获取成功');  
      } else {  
        reject('数据获取失败');  
      }  
    }, 1000);  
  });  
}  
  
fetchData()  
  .then(data => console.log(data))  
  .catch(error => console.error(error));
```

在这个例子中，`fetchData` 函数返回一个 Promise 对象，该对象在 1 秒后随机解决（resolve）或拒绝（reject）。`.then()` 方法处理成功的情况，`.catch()` 方法处理失败的情况。

## 11 浏览器限制promise并发请求次数怎么办

当浏览器限制Promise并发请求次数时，这通常是为了优化性能和避免对服务器造成过大的负荷。处理这种情况，可以通过以下几种方法来控制并发请求的数量：

### 1. 使用计数器控制并发数

**实现思路**：

- 创建一个计数器来记录当前正在进行的请求数量。
- 当发送新请求时，检查计数器的值。如果小于并发数限制，则发送请求并增加计数器的值。
- 当请求完成时（无论成功还是失败），减少计数器的值。
- 如果计数器达到并发数限制，则等待至少一个请求完成后再发送新请求。

### 2. 使用Promise队列

**实现思路**：

- 创建一个请求队列，将待发送的请求放入队列中。
- 使用一个函数来从队列中取出请求并发送，同时确保并发数不超过限制。
- 当一个请求完成时，从队列中取出下一个请求并发送。

## 12 了解websocket吗

WebSocket是HTML5下一种新的协议（websocket协议本质上是一个基于TCP的协议），它实现了浏览器与服务器之间的全双工通信，能够更好地节省服务器资源和带宽，并达到实时通讯的目的。以下是关于WebSocket的详细介绍：

### 一、WebSocket的基本特性

1. **全双工通信**：WebSocket不同于传统的HTTP请求-响应模式，它允许服务器主动推送数据到客户端，而无需客户端先发起请求，实现了真正的双向通信。
2. **长连接**：一旦WebSocket握手成功，连接将保持打开状态，直到显式关闭。这减少了频繁建立和销毁连接带来的开销，尤其适合需要持续通信的场景。
3. **轻量级头部**：WebSocket数据帧采用紧凑的二进制格式，减少了不必要的头部信息，提高了数据传输效率。
4. **实时性**：由于数据可以直接在已建立的连接上传输，WebSocket能够实现实时或接近实时的数据交互。
5. **跨域支持**：与HTTP一样，WebSocket允许跨域通信，只需服务器端设置相应的CORS（Cross-Origin Resource Sharing）头。

### 二、WebSocket的工作原理

WebSocket约定了一个通信的规范，通过一个握手机制，客户端和服务器之间能建立一个类似TCP的连接，从而方便它们之间的通信。在WebSocket出现之前，web交互一般是基于HTTP协议的短连接或者长连接。WebSocket在建立握手时，数据是通过HTTP传输的。一旦WebSocket连接建立后，后续数据都以帧序列的形式传输，直到连接被关闭。

### 三、WebSocket与HTTP的关系

- **相同点**：两者都是基于TCP的，都是可靠性传输协议，且都属于应用层协议。
- 不同点：
  - WebSocket是双向通信协议，可以双向发送或接收信息；而HTTP是单向的，通常由客户端发起请求，服务器响应。
  - WebSocket需要浏览器和服务器握手进行建立连接；而HTTP是浏览器直接发起向服务器的连接，服务器预先并不知道这个连接。
  - WebSocket在数据传输阶段，数据是以帧序列的形式传输，不需要发送HTTP头部信息；而HTTP每次请求都需要发送完整的HTTP头部信息，信息交换效率较低。

### 四、WebSocket的应用场景

WebSocket因其独特的优势，被广泛应用于需要实时通信、实时推送数据、实时同步编辑等场景，如：

- **即时聊天**：构建实时聊天应用，用户可以实时发送和接收消息，实现低延迟、高效的在线交流。
- **实时数据更新**：如实时股票行情、实时天气预报等，服务器可以实时地将最新的数据推送给客户端。
- **协同编辑**：在线文档协作、团队代码编辑等，多个用户可以同时编辑同一个文档或代码文件，编辑结果会实时同步到其他用户的界面上。
- **实时监控**：如监控设备的运行状态、实时监测交通流量等，服务器可以实时地将监控数据推送给客户端。
- **游戏开发**：开发实时多人在线游戏，多个玩家可以实时地进行游戏对战或合作。

### 五、WebSocket的优缺点

**优点**：

- 实时性：WebSocket能够实时地双向通信，服务器可以主动推送数据到客户端。
- 减少网络流量：WebSocket连接只需要进行一次握手，之后就可以保持长连接，减少了网络流量和延迟。
- 跨平台支持：WebSocket协议可以在多种平台上使用，包括桌面应用、移动应用和Web应用。

**缺点**：

- 兼容性问题：WebSocket协议在一些旧版本的浏览器上不被支持，需要通过polyfill或其他技术手段来解决。
- 服务器资源占用：由于WebSocket的长连接特性，服务器需要维护大量的连接，可能会占用较多的服务器资源。
- 安全性问题：WebSocket连接需要特殊的安全设置，以防止恶意攻击和数据泄漏。

综上所述，WebSocket作为一种现代通信技术，为web应用提供了更高效、更实时的数据交互方式，但同时也需要开发者注意其兼容性和安全性问题。

## 13 webpack核心模块

Webpack是一个用于现代JavaScript应用程序的静态模块打包工具，它能够将项目中所需的每一个模块组合成一个或多个bundles，这些bundles均为静态资源，用于在浏览器中展示内容。Webpack的核心模块主要包括以下几个方面：

### 1. 入口（Entry）

- **作用**：告诉Webpack应该使用哪个模块，来作为构建整个项目的开始。这通常是一个JavaScript文件，Webpack会从这个文件开始，分析并构建出整个项目的依赖关系图。
- **配置示例**：在Webpack的配置文件中，通过`entry`属性来指定入口文件，如`entry: './src/index.js'`。

### 2. 出口（Output）

- **作用**：告诉Webpack在哪里输出它所创建的bundle，以及如何命名这些文件。默认情况下，Webpack会输出一个名为`main.js`的文件。
- **配置示例**：在Webpack的配置文件中，通过`output`属性来配置输出文件的名称和路径，如`filename: 'bundle.js', path: path.resolve(__dirname, 'dist')`。

### 3. 加载器（Loader）

- **作用**：Webpack本身只能理解JS和JSON文件，Loader让Webpack能够去处理其他类型的文件（如CSS、图片等），并将它们转换为有效模块，以供应用程序使用。
- **工作原理**：Loader可以看作是一个转换器，它接收源文件作为输入，并将其转换为Webpack能够理解的模块。
- **配置示例**：在Webpack的配置文件中，通过`module.rules`属性来配置Loader，如`{ test: /\.css$/, use: ['style-loader', 'css-loader'] }`。

### 4. 插件（Plugins）

- **作用**：插件是Webpack的支柱功能，能够执行范围更广的任务，包括打包优化、压缩、重新定义环境中的变量等。
- **工作原理**：插件通过Webpack的钩子（hooks）与Webpack的编译流程进行交互，在特定的时刻执行特定的任务。
- **配置示例**：在Webpack的配置文件中，通过`plugins`属性来添加插件，如`new HtmlWebpackPlugin({ template: './src/index.html' })`。

### 5. 模式（Mode）

- **作用**：设置Webpack的运行模式，主要有`development`（开发模式）、`production`（生产模式）和`none`（无模式，最原始的打包方式）三种。不同的模式会影响Webpack的打包结果和性能。
- **配置示例**：在Webpack的配置文件中，通过`mode`属性来设置模式，如`mode: 'development'`。

### 总结

Webpack的核心模块包括入口（Entry）、出口（Output）、加载器（Loader）、插件（Plugins）和模式（Mode）。这些模块共同协作，使得Webpack能够高效地处理各种资源文件，并将它们打包成浏览器可以识别的静态资源。通过合理配置这些模块，可以大大提升前端项目的构建效率和运行性能。

## 14 webpack中实现热更新的原理

Webpack中实现热更新（Hot Module Replacement，简称HMR）的原理主要依赖于Webpack Dev Server和WebSocket连接，以及相关的插件和加载器。以下是详细的实现原理：

### 1. Webpack Dev Server

Webpack Dev Server是一个基于Express的小型Node.js服务器，它集成了Webpack，并提供了热模块替换功能。这个服务器在开发过程中扮演了关键角色，因为它能够实时地编译和重新加载修改后的模块，而无需手动刷新页面。

### 2. WebSocket连接

Webpack Dev Server在启动时会创建一个Socket服务器，用于与浏览器建立WebSocket连接。这种连接是双向的，允许服务器主动向浏览器推送更新信息，也允许浏览器向服务器发送请求。

### 3. 运行时脚本注入

当在浏览器中访问通过Webpack Dev Server托管的应用程序时，Webpack Dev Server会将一个运行时脚本（runtime script）注入到页面中。这个脚本会建立与Webpack Dev Server的WebSocket连接，以便实时接收来自服务器的更新通知。

### 4. 监听文件变化

Webpack通过其内置的监听机制（或外部文件系统监听工具，如`chokidar`）来监听项目文件系统的变化。一旦检测到文件被修改并保存，Webpack就会重新编译这些变化了的模块。

### 5. 模块编译与更新

编译完成后，Webpack会生成两个主要的更新文件：一个manifest文件（通常是一个JSON文件，描述了哪些模块发生了变化）和一个或多个updated chunk文件（包含实际更新后的模块代码）。这些文件被存储在内存文件系统中，以便快速访问。

### 6. 推送更新到浏览器

Webpack Dev Server通过之前建立的WebSocket连接，将manifest文件和updated chunk文件的更新信息推送给浏览器。这些信息包括新的模块ID、hash值以及文件路径等。

### 7. 浏览器处理更新

浏览器接收到更新信息后，会利用Webpack的HMR Runtime（热模块替换运行时）来处理这些更新。HMR Runtime会根据manifest文件中的信息，使用AJAX（或其他方法）拉取最新的updated chunk文件，并将其加载到应用程序中。同时，它会使用新的模块代码替换旧的模块代码，而无需重新加载整个页面。

### 8. 插件和加载器的支持

为了使热更新正常工作，还需要在Webpack配置中添加相应的插件和加载器。例如，`webpack.HotModuleReplacementPlugin`插件是启用热模块替换功能的关键，而`style-loader`加载器则支持样式文件的热更新。

### 总结

Webpack的热更新是通过Webpack Dev Server、WebSocket连接、运行时脚本注入、文件监听、模块编译与更新、推送更新到浏览器以及浏览器处理更新等步骤共同实现的。这个过程使得开发者在开发过程中能够实时地看到代码修改的效果，极大地提高了开发效率。

## 15 说一说项目的优化

### 代码分割

- **原因**：将代码分割成多个小块可以实现按需加载，提升页面加载速度。
- **实践**：使用Webpack的代码分割功能，将代码分割成多个chunk，并通过路由懒加载等方式实现按需加载。

### Tree-shaking

- **原因**：消除项目中未使用的代码，减小打包文件体积。
- **实践**：在Webpack配置中启用Tree-shaking功能，并确保项目中使用了ES6模块语法。

### 压缩和合并资源

- **压缩**：使用Webpack的压缩插件（如TerserPlugin）对JS和CSS进行压缩。
- **合并**：将多个小文件合并成一个大文件可以减少HTTP请求次数。

### 其他优化策略

- **合理使用Vuex**：对于简单应用，避免过度使用Vuex，只在需要共享状态的组件中使用。
- **优化Vue生命周期钩子的使用**：避免在生命周期钩子中进行过多的计算或异步操作。
- **使用虚拟滚动**：对于大量数据的列表，使用虚拟滚动技术只渲染可见区域的内容。
- **使用节流防抖**：在事件处理、滚动加载等场景下使用节流防抖技术减少不必要的计算和操作。

## 16 tcp三次握手四次挥手

TCP（传输控制协议）的三次握手和四次挥手是TCP/IP协议中用于建立和终止连接的重要过程。这些过程确保了数据在传输过程中的可靠性和准确性。

### TCP三次握手

TCP三次握手是TCP连接建立的过程，它确保了客户端和服务器之间能够可靠地建立连接。以下是三次握手的详细步骤：

1. 第一次握手：
   - 客户端向服务器发送一个SYN（同步序列编号）报文段，其中包含客户端的初始序列号（ISN，Initial Sequence Number），并设置SYN标志位为1。此时，客户端进入SYN_SENT（同步已发送）状态。
   - 报文段到达服务器后，服务器知道客户端想要建立连接。
2. 第二次握手：
   - 服务器向客户端发送一个SYN+ACK（同步+确认）报文段作为响应。这个报文段包含服务器的初始序列号，并对客户端的SYN报文段进行确认（ACK=客户端的ISN+1）。此时，服务器进入SYN_RCVD（同步已接收）状态。
   - 客户端收到服务器的SYN+ACK报文段后，知道服务器已经准备好建立连接。
3. 第三次握手：
   - 客户端向服务器发送一个ACK（确认）报文段，以确认收到服务器的SYN+ACK报文段（ACK=服务器的ISN+1）。此时，客户端和服务器都进入ESTABLISHED（已建立）状态，连接成功建立。
   - 服务器收到客户端的ACK报文段后，也确认连接已经建立。

**为什么需要三次握手**：

- 一次握手无法确认双方的发送和接收能力。
- 两次握手虽然可以确认客户端的发送能力和服务器的接收能力，但无法确认服务器的发送能力和客户端的接收能力。此外，两次握手还容易受到SYN洪水攻击。
- 三次握手可以确保双方都具有发送和接收数据的能力，从而建立可靠的连接。

### TCP四次挥手

TCP四次挥手是TCP连接终止的过程，它确保了客户端和服务器之间能够可靠地释放连接。以下是四次挥手的详细步骤：

1. 第一次挥手：
   - 客户端向服务器发送一个FIN（结束）报文段，请求关闭连接。此时，客户端进入FIN_WAIT_1（终止等待1）状态。
   - 报文段到达服务器后，服务器知道客户端想要关闭连接。
2. 第二次挥手：
   - 服务器向客户端发送一个ACK（确认）报文段，以确认收到客户端的FIN报文段（ACK=客户端的序列号+1）。此时，服务器进入CLOSE_WAIT（关闭等待）状态。
   - 客户端收到服务器的ACK报文段后，进入FIN_WAIT_2（终止等待2）状态，等待服务器关闭连接。
3. 第三次挥手（可选，取决于服务器是否还有数据要发送）：
   - 如果服务器已经发送完所有数据，它将向客户端发送一个FIN报文段，请求关闭连接。此时，服务器进入LAST_ACK（最后确认）状态。
   - 如果服务器还有数据要发送，它将先发送数据，然后再发送FIN报文段。
4. 第四次挥手：
   - 客户端收到服务器的FIN报文段后，向服务器发送一个ACK报文段，以确认收到服务器的FIN报文段（ACK=服务器的序列号+1）。此时，客户端进入TIME_WAIT（时间等待）状态，等待一段时间（通常是2MSL，即最长报文段寿命的两倍）以确保服务器收到ACK报文段。
   - 服务器收到客户端的ACK报文段后，进入CLOSED（已关闭）状态，连接终止。
   - 客户端在等待时间结束后，也进入CLOSED状态，连接完全终止。

**为什么需要四次挥手**：

- TCP是全双工通信协议，即数据可以在两个方向上同时传输。因此，在关闭连接时，需要确保两个方向上的数据都被正确处理和确认。
- 四次挥手可以确保双方都能可靠地释放连接资源，并避免数据丢失或连接异常终止的问题。

总的来说，TCP的三次握手和四次挥手是TCP/IP协议中非常重要的机制，它们确保了TCP连接的可靠性和准确性。

## 17 强制缓存和协商缓存

强制缓存和协商缓存是HTTP缓存机制中的两种主要类型，它们在实现方式、工作原理和应用场景上存在显著差异。以下是对这两种缓存机制的详细解析：

### 一、强制缓存

**1. 定义与特点**

强制缓存是一种无条件地从本地缓存中读取数据，而不去请求服务器的机制。当浏览器再次请求某个资源时，它首先会检查本地缓存中是否存在该资源，如果存在且未过期，则直接读取本地缓存，而不向服务器发送请求。

**2. 实现方式**

强制缓存的实现主要依赖于HTTP响应头中的两个字段：`Cache-Control`和`Expires`。

- **Cache-Control**：这是一个更加灵活和强大的缓存控制字段，可以指定缓存的行为和策略。其中，`max-age`指令用于指定资源在缓存中的最大有效时间（以秒为单位），例如`Cache-Control: max-age=3600`表示资源在缓存中的最大有效时间是3600秒（1小时）。
- **Expires**：这是一个过时的响应头字段，用于指定资源的到期时间。浏览器会在到期时间之前直接从缓存中获取资源，而不会向服务器发送请求。然而，由于`Cache-Control`字段的出现，`Expires`字段逐渐被淘汰，但在一些旧版本的浏览器或系统中可能仍然会被使用。

**3. 优点与缺点**

- **优点**：可以减少网络流量和提高页面加载速度，因为浏览器不需要向服务器发送请求来获取资源。
- **缺点**：如果资源在缓存过期之前发生了变化，用户将无法获得更新的版本。

**4. 适用场景**

强制缓存适用于那些内容变动不频繁的资源，如图片、CSS和JavaScript文件等。

### 二、协商缓存

**1. 定义与特点**

协商缓存是一种需要与服务器进行通信以验证缓存是否有效的机制。当浏览器再次请求某个资源时，它会将缓存标识（如`Last-Modified`或`ETag`）发送给服务器。服务器接收到标识后，会与当前资源的实际状态进行对比，如果状态一致，则告诉浏览器可以直接使用缓存；如果状态不一致，则返回最新的资源给浏览器。

**2. 实现方式**

协商缓存的实现主要依赖于HTTP响应头中的`Last-Modified`和`ETag`字段。

- **Last-Modified**：服务器在响应头中返回资源的最后修改时间。浏览器在下一次请求时，会通过`If-Modified-Since`请求头字段将上次请求资源时的`Last-Modified`时间发送给服务器。如果资源在这个时间之后没有被修改过，服务器会返回304 Not Modified响应，告诉浏览器可以使用缓存的资源。
- **ETag**：这是服务器返回的资源的唯一标识符，通常是一个由服务器生成的哈希值或版本号。浏览器在下一次请求时，会通过`If-None-Match`请求头字段将上次请求资源时的`ETag`发送给服务器。如果资源的`ETag`没有改变，服务器会返回304 Not Modified响应，告诉浏览器可以使用缓存的资源。

**3. 优点与缺点**

- **优点**：可以解决强制缓存机制的缺点，即使资源在缓存过期后发生了变化，仍然可以减少网络流量，提高页面加载速度。
- **缺点**：相比强制缓存，协商缓存需要向服务器发送请求来验证资源是否发生了变化，因此会增加一定的网络延迟。

**4. 适用场景**

协商缓存适用于内容变动频繁的资源，如新闻文章或产品详情页等。

### 三、总结

强制缓存和协商缓存是两种不同类型的缓存机制，它们各有优缺点并适用于不同的场景。在实际应用中，我们可以根据资源的特性和更新频率选择合适的缓存策略，结合使用强制缓存和协商缓存在Web性能优化中取得更好的效果。

## 18 请求状态码 401 500 502 206

HTTP请求状态码是用来表示HTTP请求是否成功，以及服务器对请求的处理结果的一组数字代码。这些状态码可以分为五大类：信息性状态码（1xx）、成功状态码（2xx）、重定向状态码（3xx）、客户端错误状态码（4xx）和服务器错误状态码（5xx）。以下是一些常见的HTTP请求状态码及其含义：

### 1xx 信息性状态码

- **100 Continue**：表示服务器已经接收到请求的一部分，客户端可以继续发送剩余的请求。

### 2xx 成功状态码

- **200 OK**：表示请求已成功处理，并返回所请求的资源。
- **201 Created**：表示请求已成功处理，并在服务器上创建了新的资源。
- **204 No Content**：表示服务器成功处理了请求，但没有返回任何内容。
- **206 Partial Content**：表示服务器已经成功处理了部分GET请求，客户端进行了范围请求，并成功执行了这部分的GET请求。

### 3xx 重定向状态码

- **301 Moved Permanently**：表示请求的网页已永久移动到新位置，新的URL会在响应的Location头字段里找到。
- **302 Found**（虽然常被称为“临时重定向”，但HTTP/1.1规范中已将其定义为“Found”，意味着临时移动，但客户端应继续使用新的URL进行后续请求）。
- **304 Not Modified**：表示客户端发送了一个条件请求，服务器判断资源未发生变化，返回此状态码。

### 4xx 客户端错误状态码

- **400 Bad Request**：表示服务器无法理解请求的语法。
- **401 Unauthorized**：表示请求需要身份验证，验证后才能获取所请求的内容。
- **403 Forbidden**：表示服务器拒绝请求访问，通常代表客户端错误，服务器端有能力处理请求，但是拒绝授权访问。
- **404 Not Found**：表示服务器找不到请求的资源，可能是链接失效、URL拼写错误或资源被移动。
- **408 Request Timeout**：表示服务器等待客户端发送的请求时间过长。

### 5xx 服务器错误状态码

- **500 Internal Server Error**：表示服务器内部错误，无法完成请求，通常是由于程序代码或服务器配置问题。
- **502 Bad Gateway**：表示服务器作为网关或代理，从上游服务器接收到无效响应。
- **503 Service Unavailable**：表示服务器暂时无法处理请求，通常是由于过载或维护。

除了上述常见的状态码外，还有其他一些状态码，如405 Method Not Allowed（请求方法不被允许）、429 Too Many Requests（客户端发送的请求过多，超出了服务器的处理能力）以及504 Gateway Timeout（服务器作为网关或代理，等待上游服务器响应超时）等。

这些状态码为客户端和服务器之间的通信提供了标准化的反馈机制，有助于诊断和解决网络通信中的问题。

## 19 js的数据类型

JavaScript 是一种动态类型的语言，这意味着你不需要在声明变量时指定其类型。然而，JavaScript 引擎在运行时确实会给变量赋予一种类型，以便正确地执行程序。JavaScript 中的数据类型主要可以分为两大类：原始数据类型（Primitive Types）和对象类型（Object Types）。

### 原始数据类型（Primitive Types）

原始数据类型是值类型，它们存储在栈（stack）内存中，并且它们的值是不可变的（即，如果你改变了某个原始数据类型的值，实际上是在内存中的另一个位置创建了一个新的值）。原始数据类型包括以下几种：

1. **String**：文本字符串。
2. **Number**：数值。JavaScript 中的数字可以是整数或浮点数，并且支持科学记数法。
3. **BigInt**：任意长度的整数。这是一个比较新的类型，用于表示大于 `2^53 - 1` 的整数。
4. **Boolean**：逻辑值，`true` 或 `false`。
5. **Undefined**：一个特殊的值，用于表示变量已被声明但未被赋值。
6. **Null**：一个特殊的值，表示空对象引用。
7. **Symbol**（ES6 引入）：一个独一无二的值，主要用作对象的属性名。

### 对象类型（Object Types）

对象类型（或称为引用类型）是存储在堆（heap）内存中的数据结构，可以包含多个值（属性）作为成员。在 JavaScript 中，除了原始数据类型之外的所有数据类型都是对象类型。常见的对象类型包括：

1. **Object**：JavaScript 中所有对象的基类。
2. **Array**：用于存储有序集合的数组。尽管 `Array` 看起来像是一个原始数据类型，但它实际上是 `Object` 类型的一个子类。
3. **Function**：函数对象，可以包含可执行代码。
4. **Date**：表示日期和时间的对象。
5. **RegExp**：表示正则表达式的对象，用于字符串搜索和替换等。
6. **Error**：表示运行时错误的对象。

此外，JavaScript 还支持用户定义的对象（通过 `class` 关键字或构造函数创建的对象）和内置对象（如 `Math`、`JSON` 等，它们提供了数学运算、JSON 解析等功能）。

需要注意的是，虽然 JavaScript 是动态类型的，但在某些情况下，我们可以使用类型注解（TypeScript）或类型检查（如 `typeof` 运算符）来明确或检查变量的类型。然而，这些只是辅助工具，不是 JavaScript 语言本身的强制要求。

## 20 怎么判断js的数据类型

在JavaScript中，有几种方式可以用来判断一个变量的数据类型。由于JavaScript是动态类型的，变量本身不绑定到任何特定的数据类型，但你可以检查变量当前持有的值的类型。以下是一些常用的方法来判断JavaScript中变量的数据类型：

### 1. `typeof` 运算符

`typeof` 运算符是判断JavaScript变量数据类型的最基本方式。它可以返回以下字符串之一："number"、"string"、"boolean"、"undefined"、"object"、"function"、"symbol"（ES6新增）。但是，对于数组和`null`，它都会返回`"object"`，这可能会导致一些混淆。

```javascript
console.log(typeof 123);    // "number"  
console.log(typeof "abc");  // "string"  
console.log(typeof true);   // "boolean"  
console.log(typeof undefined); // "undefined"  
console.log(typeof null);   // "object" 注意这里的特殊情况  
console.log(typeof []);     // "object" 数组也是object  
console.log(typeof {});     // "object" 对象字面量  
console.log(typeof function(){}); // "function"  
console.log(typeof Symbol()); // "symbol"
```

### 2. `instanceof` 运算符

`instanceof` 运算符用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上。这可以用来判断一个对象是否是其原型链上某个构造函数的实例。它对于数组和自定义对象类型的判断特别有用。

```javascript
console.log([] instanceof Array); // true  
console.log({} instanceof Object); // true  
console.log(new Date() instanceof Date); // true
```

但是，`instanceof` 对于基本数据类型（如`number`、`string`、`boolean`）不适用，因为它们是原始值，不是对象。

### 3. `Object.prototype.toString.call()` 方法

这是一个非常强大的方法，可以准确地返回JavaScript中任何值的类型，包括原始类型和对象类型。

```javascript
console.log(Object.prototype.toString.call(123));       // "[object Number]"  
console.log(Object.prototype.toString.call("abc"));     // "[object String]"  
console.log(Object.prototype.toString.call(true));      // "[object Boolean]"  
console.log(Object.prototype.toString.call(undefined)); // "[object Undefined]"  
console.log(Object.prototype.toString.call(null));      // "[object Null]"  
console.log(Object.prototype.toString.call([]));        // "[object Array]"  
console.log(Object.prototype.toString.call({}));        // "[object Object]"  
console.log(Object.prototype.toString.call(function(){})); // "[object Function]"
```

注意，虽然这种方法非常准确，但代码相对较长，因此在一些简单的情况下可能不是最简洁的选择。

### 4. ES6+ 中的 `Array.isArray()` 和 `typeof Symbol.iterator`

对于特定的类型，如数组和Symbol，JavaScript提供了专门的函数或属性来检查。

- `Array.isArray()`：用来判断一个值是否为数组。
- `typeof Symbol.iterator`：可以用来检查一个对象是否实现了迭代器接口（这可以用来检测某些类型的集合，如`Map`、`Set`等）。

```javascript
console.log(Array.isArray([])); // true  
console.log(typeof Symbol.iterator in {}); // false  
console.log(typeof Symbol.iterator in new Map()); // true
```

## 21 undefined == null返回什么 为什么

在JavaScript中，`undefined == null` 返回的是 `true`。

ECMAScript 规范认为，既然 null 和  undefined 的行为很相似，并且都表示 一个无效的值，那么它们所表示的内容也具有相似性，即有

```javascript
undefined == null; //true
```

   不要试图通过转换数据类型来解释这个结论，因为：

```javascript
Number(null); // 0
Number(undefined); // NaN
//在比较相等性之前，null 没有被转换为其他类型
null == 0 ; //false
```

   但 === 会返回 false ，因为全等操作 === 在比较相等性的时候，不会主动转换分项的数据类型，而两者又不属于同一种类型：

```javascript
undefined === null; //false，类型不相同
undefined !== null;  //true, 类型不相同
```

**总结**

​    用一句话总结两者的区别就是：undefined 表示一个变量自然的、最原始的状态值，而 null 则表示一个变量被人为的设置为空对象，而不是原始状态。所以，在实际使用过程中，为了保证变量所代表的语义，不要对一个变量显式的赋值 undefined，当需要释放一个对象时，直接赋值为 null 即可。

## 22 arr instanceof Array 判断会出错吗

`arr instanceof Array` 这种方式在大多数情况下是有效的，用于判断一个变量 `arr` 是否是 `Array` 类型。然而，在某些特殊情况下，这种判断方式可能会出错或不符合预期。以下是一些可能导致 `arr instanceof Array` 出错或表现不符合预期的情况：

1. **跨iframe或窗口对象**：如果 `arr` 是从一个不同的iframe或窗口（window）中获得的，那么 `arr instanceof Array` 可能不会返回 `true`，因为 `Array` 构造函数在不同的全局环境中是不同的。
2. **通过 `Object.create(null)` 创建的对象**：虽然这通常不直接涉及数组的判断，但如果有人通过类似的方式“模拟”了数组的行为（例如，通过设置 `length` 属性和索引属性），`instanceof Array` 将无法识别这样的对象为数组。
3. **修改或重写 `Array` 构造函数**：在极端情况下，如果 `Array` 构造函数被修改或重写（虽然这在实际开发中非常罕见），`instanceof Array` 的行为可能会受到影响。
4. **使用 `Array.isArray()` 方法**：为了更可靠地判断一个值是否为数组，建议使用 `Array.isArray(arr)` 方法。这个方法比 `instanceof Array` 更可靠，因为它不依赖于全局执行上下文中的 `Array` 构造函数。
5. **框架和库的影响**：在某些JavaScript框架或库中，可能使用了特殊的技术（如代理、封装等）来处理数组或类似数组的对象。在这些情况下，`instanceof Array` 可能无法正确识别这些对象。
6. **非标准全局环境**：在一些非标准的JavaScript环境中（如某些Node.js模块系统或特殊的JavaScript执行环境），全局的 `Array` 构造函数可能与标准环境不同，这可能导致 `instanceof Array` 的行为不符合预期。

综上所述，虽然 `arr instanceof Array` 在大多数情况下是有效的，但在某些特殊情况下可能会出错。为了确保代码的健壮性和可移植性，建议使用 `Array.isArray(arr)` 方法来判断一个值是否为数组。

## 23 深拷贝与浅拷贝

深拷贝与浅拷贝是计算机科学中，特别是在面向对象编程中常见的概念，它们涉及到对象复制时的不同行为。以下是对两者的详细解释及区别：

### 一、定义

1. **浅拷贝（Shallow Copy）**
   - 浅拷贝是指重新分配一块内存，创建一个新的对象，但这个新对象中的元素是原对象中各个子对象的引用。也就是说，如果原对象中的属性是基本数据类型（如int、float等），则这些属性的值会被复制到新对象中；但如果属性是引用数据类型（如对象、数组等），则只复制该属性的引用地址，而不复制引用的对象本身。
   - 浅拷贝的结果是，新对象和原对象共享某些子对象（引用类型属性指向的对象）。因此，如果修改了这些共享的子对象，那么原对象和新对象都会受到影响。
2. **深拷贝（Deep Copy）**
   - 深拷贝是指重新分配一块内存，创建一个新的对象，并且递归地将原对象中的元素（包括子对象）拷贝到新对象中。也就是说，对于原对象中的每一个属性，无论是基本数据类型还是引用数据类型，都会创建一个新的副本，并将其放置在新对象中。
   - 深拷贝的结果是，新对象和原对象完全独立，没有任何共享的子对象。因此，修改新对象中的任何属性都不会影响原对象，反之亦然。

### 二、区别

1. **直接区别**
   - 浅拷贝：新对象和原对象部分属性地址相等（共享子对象），新对象并没有拷贝所有的属性，而是复用原对象中的值。
   - 深拷贝：新对象和原对象不仅地址不相等，而且两个对象的所有属性地址都不相等。
2. **内在区别**
   - 浅拷贝：简单地复制引用地址，没有开辟新的内存空间来存放对象副本。
   - 深拷贝：实实在在地复制对象值，包括对象引用的其他对象，并开辟新的内存空间来存放对象副本。
3. **影响**
   - 浅拷贝：由于新对象和原对象共享某些子对象，因此修改这些子对象会同时影响新对象和原对象。
   - 深拷贝：新对象和原对象完全独立，修改新对象中的任何属性都不会影响原对象，反之亦然。

### 三、实现方式

1. **浅拷贝的实现方式**
   - 在Java中，可以使用`Object.clone()`方法（如果类实现了`Cloneable`接口）或`System.arraycopy()`方法来实现数组的浅拷贝。
   - 在JavaScript中，可以使用`Object.assign()`方法或数组的`slice()`、`concat()`等方法来实现对象的浅拷贝。
2. **深拷贝的实现方式**
   - 在Java中，可以通过重写`clone()`方法或使用序列化/反序列化机制来实现深拷贝。
   - 在JavaScript中，可以使用递归方法实现深度克隆，或者使用JSON序列化/反序列化（`JSON.parse(JSON.stringify(obj))`）来实现深拷贝（但这种方法有局限性，如无法处理函数、`undefined`、循环引用等）。

### 四、应用场景

- 当对象中的属性主要是基本数据类型时，可以使用浅拷贝来节省内存和时间。
- 当对象中包含大量的引用数据类型，且需要保证对象之间的独立性时，应该使用深拷贝。

总之，深拷贝与浅拷贝在对象复制时具有不同的行为和影响，选择哪种拷贝方式取决于具体的应用场景和需求。

## 24 深拷贝的实现方式

深拷贝的实现方式多种多样，每种方式都有其特定的应用场景和优缺点。以下是一些常见的深拷贝实现方式：

### 1. 递归方式

递归方式是深拷贝中最常用且最基础的方法之一。它通过遍历对象、数组等数据结构，对每一个属性或元素进行递归拷贝，直到遇到基本数据类型为止。这种方法可以精确地复制出原对象的所有结构和数据，包括嵌套的对象和数组。

```js
function deepClone(obj, hash = new WeakMap()) {  
  // 处理基本数据类型、null 和 undefined  
  if (obj === null || typeof obj !== 'object') {  
    return obj;  
  }  
  
  // 处理循环引用  
  if (hash.has(obj)) {  
    return hash.get(obj);  
  }  
  
  // 处理Date对象  
  if (obj instanceof Date) {  
    return new Date(obj);  
  }  
  
  // 处理RegExp对象  
  if (obj instanceof RegExp) {  
    // 注意：RegExp的flags属性在ES6中引入  
    const flags = obj.flags ? `/${obj.source}/${obj.flags}` : `/${obj.source}/`;  
    return new RegExp(flags);  
  }  
  
  // 处理其他非普通对象（如Map, Set, Blob, File等）  
  // 这里可以根据需要添加更多的类型处理  
  
  // 处理普通对象或数组  
  let cloneObj = Array.isArray(obj) ? [] : {};  
  hash.set(obj, cloneObj); // 将原始对象和克隆对象存入hash表，处理循环引用  
  
  // 递归拷贝对象的每个属性  
  for (let key in obj) {  
    if (obj.hasOwnProperty(key)) {  
      cloneObj[key] = deepClone(obj[key], hash);  
    }  
  }  
  
  // 对于Object.prototype上的属性，上面的循环不会处理，如果需要可以手动添加  
  // 例如：Object.getOwnPropertySymbols(obj).forEach(sym => {  
  //   if (obj.hasOwnProperty(sym)) {  
  //     cloneObj[sym] = deepClone(obj[sym], hash);  
  //   }  
  // });  
  
  return cloneObj;  
}  
  
// 测试代码  
const original = {  
  a: 1,  
  b: { c: 2, d: [3, 4] },  
  date: new Date(),  
  reg: /hello/gi,  
  fn: function() { console.log('fn'); },  
  // 可以添加更多类型的测试数据  
};  
  
original.b.d.push(original); // 创建一个循环引用  
  
const cloned = deepClone(original);  
console.log(cloned);  
console.log(cloned.b.d[2] === original); // false，说明循环引用被正确处理  
console.log(cloned.fn === original.fn); // true，函数是引用类型，只拷贝引用
```

- 对于包含大量嵌套结构或循环引用的对象，可能会导致性能问题或栈溢出。
- 需要手动处理特殊数据类型（如函数、`Date`、`RegExp`等）的拷贝。

### 2. JSON序列化与反序列化

JSON序列化与反序列化是另一种实现深拷贝的简便方法。它通过将对象转换为JSON格式的字符串，然后再将字符串解析回对象的方式来实现深拷贝。这种方法简单易行，但有一些限制和注意事项。

**实现步骤**：

1. 使用`JSON.stringify()`方法将对象转换为JSON格式的字符串。
2. 使用`JSON.parse()`方法将JSON字符串解析回对象。

```js
newObj = JSON.parse(JSON.stringify(obj))
```

**优点**：

- 实现简单，代码量少。
- 可以处理大多数数据类型，包括嵌套的对象和数组。

**缺点**：

- 无法处理函数、`undefined`、`Symbol`等特殊数据类型。
- 无法保持对象的原型链和不可枚举属性。
- 对于包含循环引用的对象，会抛出错误。

### 3. 使用库函数

在实际开发中，为了提高开发效率和减少出错的可能性，很多开发者会选择使用现成的库函数来实现深拷贝。例如，Lodash库中的`_.cloneDeep()`方法就是一个非常流行的深拷贝实现。

**优点**：

- 实现稳定可靠。
- 可以处理各种复杂的数据类型和场景。
- 易于集成和使用。

**缺点**：

- 需要引入外部库，增加项目的依赖和体积。

### 4. 其他方式

除了上述三种常见方式外，还有一些其他实现深拷贝的方法，如使用`Object.create()`结合`Object.assign()`（但这种方法通常只适用于浅拷贝），或者使用`MessageChannel`等Web API来实现跨域的深拷贝等。这些方法各有特点和应用场景，开发者可以根据实际需求选择使用。

### 总结

深拷贝的实现方式多种多样，每种方式都有其独特的优缺点和适用场景。在选择实现方式时，需要综合考虑项目的具体需求、性能要求、代码复杂度等因素。对于大多数情况来说，递归方式和JSON序列化与反序列化是两种非常实用且常用的深拷贝实现方式。如果项目中已经使用了Lodash等库，则可以直接使用库中的深拷贝函数来简化开发过程。

## 25 为什么JSON.parse JSON.stringify做拷贝会导致信息丢失

`JSON.parse(JSON.stringify(obj))` 是一种在JavaScript中常用的快速深拷贝技巧，但它确实会导致一些信息丢失，这主要是因为JSON格式本身的限制以及JavaScript对象与JSON对象之间的差异。以下是导致信息丢失的几个主要原因：

1. 函数、`undefined`、`Symbol`和特殊对象丢失：
   - **函数**：JSON格式不支持函数，因此任何在原始对象中的函数都会被忽略。
   - **`undefined`**：在JSON中，`undefined` 值会被忽略（在序列化过程中被自动删除），并且在解析回JavaScript对象时不会恢复。
   - **`Symbol`**：`Symbol` 值在JSON中也不被支持，因此它们会被忽略。
   - **特殊对象**：如`Map`、`Set`、`Date`、`RegExp`、`Blob`、`File`等，虽然`JSON.stringify`可以处理`Date`和`RegExp`（通过将它们转换为字符串），但其他特殊对象会丢失其特定的行为或属性。
2. 循环引用：
   - 如果对象中存在循环引用（即对象通过其属性间接或直接地引用了自己），`JSON.stringify`会抛出错误，因为它无法处理这种情况。
3. 非枚举属性丢失：
   - `JSON.stringify`只序列化对象自身的可枚举属性。如果对象上有非枚举属性（即使用`Object.defineProperty`定义且`enumerable`属性设置为`false`的属性），这些属性将不会被序列化。
4. 精度丢失：
   - 对于非常大的数字，JSON可能会丢失精度，因为JSON中的数字是以双精度浮点数格式存储的。这意味着某些非常大的整数或非常小的数在转换回JavaScript时可能会不准确。
5. 原型链丢失：
   - `JSON.parse(JSON.stringify(obj))` 创建的新对象是一个普通的JavaScript对象（`{}`），它不会继承原始对象的原型链。如果原始对象有自定义的原型方法或属性，这些都不会被复制到新对象中。
6. `BigInt`：
   - `BigInt` 是一种内置对象，它提供了一种方法来表示大于 `2^53 - 1` 的整数。然而，`JSON.stringify` 不能序列化 `BigInt` 类型的值，会将其转换为字符串（如果可能的话），或者在某些情况下抛出错误。

因此，虽然 `JSON.parse(JSON.stringify(obj))` 是一种快速且简单的深拷贝方法，但它并不适用于所有情况。在需要精确控制深拷贝行为或处理特殊数据类型时，应该使用更复杂的深拷贝函数或库。

## 26 localStorage sessionStorage和cookie

`localStorage`、`sessionStorage` 和 `cookie` 是Web存储解决方案的三种主要方式，它们各自有不同的用途和特性。下面是它们之间的主要区别：

### 1. 存储位置与大小

- **cookie**：存储在用户的浏览器上，但是每次HTTP请求都会携带cookie信息到服务器，这会增加请求的大小，并可能影响性能。单个cookie的大小限制为4KB（尽管浏览器之间可能有所不同），整个域名下的cookie总数也有限制（如20个）。
- **localStorage**：存储在用户的浏览器上，但它不会随着每个HTTP请求发送到服务器。它的大小限制比cookie大得多，一般为5MB（这个值可能会根据浏览器而有所不同）。
- **sessionStorage**：也是存储在用户的浏览器上，与localStorage类似，但它仅在当前会话期间有效，即浏览器标签页打开期间。一旦浏览器标签页被关闭，存储的数据就会被清除。sessionStorage的大小限制通常与localStorage相同。

### 2. 生命周期

- **cookie**：可以设置过期时间（expires/max-age），也可以在浏览器会话结束时过期（会话cookie）。
- **localStorage**：数据会一直存储在用户的浏览器中，直到被显式删除或用户清除浏览器缓存。
- **sessionStorage**：数据在页面会话期间存在，页面会话在浏览器标签页打开期间持续，并且重新加载或恢复页面仍会保持同一个会话。一旦浏览器标签页被关闭，数据就会被清除。

### 3. 访问范围

- **cookie**：默认情况下，同一域名下的所有页面都可以访问该域名下的cookie。但是，可以通过设置`HttpOnly`和`Secure`属性来限制对cookie的访问，以提高安全性。
- **localStorage**：同一个域下的所有页面都可以访问和修改localStorage中的数据。
- **sessionStorage**：仅限于在当前浏览器标签页中访问和修改，即使是同一域名下的不同标签页也无法访问彼此的sessionStorage数据。

### 4. 安全性

- **cookie**：可以通过设置`HttpOnly`和`Secure`属性来提高安全性，防止XSS攻击和CSRF攻击。但是，由于它们会随每个HTTP请求发送到服务器，因此可能会受到中间人攻击的风险。
- **localStorage** 和 **sessionStorage**：存储在浏览器端，不会随HTTP请求发送到服务器，因此相对于cookie来说，它们在某种程度上更安全。但是，它们仍然可能受到XSS攻击的风险，因为攻击者可以通过XSS漏洞访问和修改这些存储的数据。

## 27 sessionStorage刷新页面会丢失吗

**sessionStorage 在页面刷新时不会丢失数据**。sessionStorage 是 Web Storage API 的一部分，它允许你在同一个浏览器标签页会话中存储数据。这意味着只要浏览器标签页保持打开状态，存储在 sessionStorage 中的数据就会一直存在，即使页面被刷新。

然而，如果你关闭了浏览器标签页，或者打开了新的浏览器标签页（即使它们访问的是同一个网站），那么 sessionStorage 中的数据就会丢失，因为它仅限于当前浏览器标签页的会话。

## 28 怎么测出localStorage的浏览器内存大小限制

要测出localStorage的浏览器内存大小限制，可以通过编写JavaScript代码来尝试向localStorage中添加数据，直到达到其存储上限为止。以下是一个基本的方法来测试localStorage的浏览器内存大小限制：

### 测试步骤

1. 初始化变量

   ：

   - 创建一个字符串变量，用于存储将要添加到localStorage中的数据。
   - 设定一个初始大小（如1MB），并逐渐增加这个大小，直到达到上限。

2. 循环添加数据

   ：

   - 在一个循环中，创建适当大小的数据（如使用`Array.fill()`和`Array.join('')`来生成一个字符串），并尝试使用`localStorage.setItem()`方法将其添加到localStorage中。
   - 每次循环时，检查是否抛出了异常（如`QuotaExceededError`或`DOMException`），这通常意味着已经达到了存储上限。

3. 记录并输出结果

   ：

   - 当捕获到异常时，记录下当前尝试添加的数据大小，这就是localStorage的大致存储上限。
   - 输出结果，以便了解当前浏览器的localStorage存储限制。

### 示例代码

```javascript
function testLocalStorageLimit() {  
    let blockSize = 1024 * 1024; // 1MB  
    let limit = 0;  
    let key = 'testLimit';  
  
    try {  
        while (true) {  
            let data = new Array(blockSize).fill('a').join('');  
            localStorage.setItem(key, data);  
            limit += blockSize;  
            blockSize *= 2; // 每次加倍尝试，以更快地接近上限  
        }  
    } catch (e) {  
        if (e.name === 'QuotaExceededError' || e.message.indexOf('exceeded the quota') !== -1) {  
            // 当达到存储上限时，会抛出异常  
            console.log(`localStorage limit is approximately ${(limit - blockSize).toFixed(2)} MB`);  
            localStorage.removeItem(key); // 清理测试数据  
        } else {  
            // 其他错误处理  
            console.error('Error testing localStorage limit:', e);  
        }  
    }  
}  
  
testLocalStorageLimit();
```

### 注意事项

- **不同浏览器的限制可能不同**：localStorage的存储限制因浏览器而异，通常在5MB到10MB之间。
- **用户设置和浏览器策略**：用户或浏览器策略可能会限制localStorage的可用空间。
- **代码执行环境**：在某些情况下（如某些WebView或移动浏览器），localStorage的行为可能与标准浏览器有所不同。
- **测试精度**：由于测试方法是基于逐步增加数据大小并捕获异常，因此测试得到的限制可能是一个近似值，而不是精确值。

### 结论

通过上述方法，你可以大致测试出当前浏览器localStorage的存储限制。然而，需要注意的是，由于各种因素的影响，测试结果可能会有所不同。

## 29 使用闭包实现依次打印2 3 5

要使用闭包实现依次打印2, 3, 5，我们需要创建一个闭包环境，这个环境能够记住当前的索引或状态，并且允许我们逐步访问并更新这些值。下面是一个简单的实现方式，它使用闭包和立即执行函数（IIFE）来创建一个作用域，并在这个作用域内维护一个状态数组和当前索引。然后，我们使用`setTimeout`来模拟异步操作，以便在每次迭代后延迟打印。

```javascript
(function printNumbers() {  
    // 定义一个包含要打印的数字的数组  
    const numbers = [2, 3, 5];  
    // 当前要打印的数字的索引  
    let currentIndex = 0;  
  
    // 定义一个闭包函数，该函数会打印当前索引对应的数字，并递增索引  
    function printNextNumber() {  
        if (currentIndex < numbers.length) {  
            // 打印当前数字  
            console.log(numbers[currentIndex]);  
            // 更新索引  
            currentIndex++;  
            // 使用setTimeout来异步调用自身，以模拟逐步打印  
            setTimeout(printNextNumber, 1000); // 延迟1000毫秒  
        }  
    }  
  
    // 启动打印过程  
    printNextNumber();  
})();
```

在这个例子中，`printNumbers`是一个立即执行函数表达式（IIFE），它创建了一个自己的作用域，包含`numbers`数组和`currentIndex`变量。`printNextNumber`函数是这个作用域内部的一个闭包，因为它记住了外部作用域中的`numbers`和`currentIndex`变量。`printNextNumber`函数首先检查是否还有数字需要打印，如果有，则打印当前索引对应的数字，更新索引，并使用`setTimeout`延迟1000毫秒后再次调用自己。这样，就能依次打印出数组中的数字2, 3, 5了。

## 30 看代码说输出

```js
function fun(){
    var a=b=c=5
}
fun()
console.log(a) // 报错 a的作用域为块级作用域
console.log(b) // b c为全局 打印5 5
console.log(c)
```



```js
console.log(a = 1)
a = 2
console.log(a);
console.log(arr = [])
arr.push(1)
console.log(arr);
```



## 31 反问 现在应该继续学习什么

多学习js，找项目中出现的问题，并解决理解问题

## 32 反问 公司的技术栈

老项目vue2 新项目vue3 部分uniapp开发微信小程序

 

# 长沙 腾讯云智 一面 2024-06-05 37min

## 1 为什么会选择前端

## 2 怎么学习前端的

## 3 看过什么有关前端的书

## 4 有没有读研方面的规划

## 5 js数据类型

## 6 怎么判断js数据类型

## 7 说一下有哪些数据结构

## 8 js实现二叉树

## 9 计算机网络七层模型

## 10 HTTP协议 TCP UDP协议都在哪一层

## 11 浏览器输入url到界面展示的流程

## 12 TCP 三次握手四次挥手

## 13 HTTP和HTTPS的区别

## 14 HTTP2是什么

## 15 事件循环

## 16 手撕代码 寻找重复出现的单词

## 17 vue和react的区别

## 18 平时遇到困难怎么解决

## 19 印象最深的问题

## 20 反问 公司的业务方向

# 北京 快看漫画 一面 2024-06-06 25min

## 1 浏览器输入url到界面显示的流程

## 2 哪些操作会引起重排重绘

## 3 介绍一下flex布局

## 4 怎么实现元素居中

## 5 怎么实现三栏布局

## 6 TCP和UDP的区别

## 7 TCP 三次握手四次挥手

## 8 强制缓存和协商缓存

## 9 vue生命周期

## 10 v-if和v-show

## 11 vue组件传值

## 12 事件循环 微任务和宏任务都有什么

## 13 多维数组转一维数组

在JavaScript中，将多维数组转换为一维数组是一个常见的需求。这可以通过递归函数、`Array.prototype.flat()`方法（ES2019+），或者使用迭代和`Array.prototype.concat()`/`Array.prototype.push()`/`spread operator`（扩展运算符）等方法来实现。以下是几种不同方法的示例：

### 1. 使用`flat()`方法（最简单）

如果你的环境支持ES2019（或更高版本），你可以使用`flat()`方法，它可以将多维数组转换为一维数组，并接受一个可选的深度参数来指定转换的层级。如果不指定深度，默认值为1，但你可以设置为`Infinity`来展开任意深度的数组。

```javascript
const multiDimArray = [1, [2, 3], [4, [5, 6]]];  
const flatArray = multiDimArray.flat(Infinity);  
console.log(flatArray); // [1, 2, 3, 4, 5, 6]
```

### 2. 使用递归函数

如果你需要一个更通用的解决方案，或者你的环境不支持`flat()`方法，你可以编写一个递归函数来遍历多维数组并构建一维数组。

```javascript
function flattenArray(arr) {  
  let result = [];  
  for (let i = 0; i < arr.length; i++) {  
    if (Array.isArray(arr[i])) {  
      // 如果当前元素是数组，则递归调用 flattenArray  
      result = result.concat(flattenArray(arr[i]));  
    } else {  
      // 如果不是数组，直接添加到结果数组中  
      result.push(arr[i]);  
    }  
  }  
  return result;  
}  
  
const multiDimArray = [1, [2, 3], [4, [5, 6]]];  
const flatArray = flattenArray(multiDimArray);  
console.log(flatArray); // [1, 2, 3, 4, 5, 6]
```

### 3. 使用`reduce()`和`concat()`

类似于递归函数，但使用`reduce()`来简化迭代过程。

```javascript
function flattenArray(arr) {  
  return arr.reduce((acc, val) => acc.concat(Array.isArray(val) ? flattenArray(val) : [val]), []);  
}  
  
const multiDimArray = [1, [2, 3], [4, [5, 6]]];  
const flatArray = flattenArray(multiDimArray);  
console.log(flatArray); // [1, 2, 3, 4, 5, 6]
```

### 4. 使用扩展运算符（`...`）

如果你知道数组的最大深度，并且这个深度不是很大，你可以使用扩展运算符和递归或迭代来手动展开数组。但是，这种方法对于未知深度的数组来说不太实用。

对于已知深度的简单示例（假设最大深度为2）：

```javascript
const multiDimArray = [1, [2, 3], [4, [5, 6]]];  
// 假设我们知道最大深度为2，可以这样做：  
const flatArray = [].concat(...multiDimArray.map(x => Array.isArray(x) ? [...x] : [x]));  
// 但注意，这只能处理到第二层的嵌套  
console.log(flatArray); // [1, 2, 3, 4, [5, 6]] - 这不是完全平坦的  
  
// 对于更深层次的嵌套，还是需要递归或使用flat()
```

注意：使用扩展运算符的这种方法在处理深层嵌套时并不有效，因为它只能展开一层。对于深层嵌套，你应该使用`flat()`、递归函数或`reduce()`等方法。

## 14 反问 公司的业务

# 杭州 袋鼠云 一面 2024-06-07 26min

## 1 笔试 数组转对象

在JavaScript中，将数组转换为对象（通常是将数组中的每个元素作为对象的键或值，或者同时作为键和值）是一个常见的操作。这里有几种常见的方法来实现这个转换。

### 1. 使用 `reduce` 方法

`reduce` 方法是数组的一个高阶函数，它可以将数组中的所有元素归纳（或“减少”）为单个值。你可以使用它来构建一个新对象。

#### 示例：将数组元素作为对象的键，值统一为 `true` 或 `null`

```javascript
const array = ['a', 'b', 'c'];  
  
// 使用 reduce 方法将数组转换为对象，键为数组元素，值为 true  
const obj = array.reduce((acc, curr) => {  
  acc[curr] = true;  
  return acc;  
}, {});  
  
console.log(obj); // { a: true, b: true, c: true }
```

#### 示例：将数组元素同时作为对象的键和值

```javascript
const array = ['a', 'b', 'c'];  
  
// 使用 reduce 方法将数组转换为对象，键和值都为数组元素  
const obj = array.reduce((acc, curr) => {  
  acc[curr] = curr;  
  return acc;  
}, {});  
  
console.log(obj); // { a: 'a', b: 'b', c: 'c' }
```

### 2. 使用 `Object.fromEntries` 和 `map`

如果你需要将数组的每个元素（或元素的某种转换）作为对象的键或值对，可以先使用 `map` 方法转换数组，然后使用 `Object.fromEntries` 方法将键值对数组转换为对象。

#### 示例：将数组元素作为对象的键，值统一为 `true`

```javascript
const array = ['a', 'b', 'c'];  
  
// 使用 map 方法生成键值对数组，然后使用 Object.fromEntries 转换为对象  
const obj = Object.fromEntries(array.map(key => [key, true]));  
  
console.log(obj); // { a: true, b: true, c: true }
```

### 3. 简单的循环

对于简单的场景，你也可以使用传统的 `for` 循环或 `forEach` 方法来遍历数组，并逐个设置对象的属性。

#### 示例：将数组元素作为对象的键，值统一为 `true`

```javascript
const array = ['a', 'b', 'c'];  
const obj = {};  
  
array.forEach(key => {  
  obj[key] = true;  
});  
  
console.log(obj); // { a: true, b: true, c: true }
```

以上是几种将数组转换为对象的常见方法。选择哪种方法取决于你的具体需求以及你对代码可读性和性能的考虑。

## 2 笔试 对象转数组

在JavaScript中，将对象转换为数组并不是一个直接的过程，因为对象和数组在本质上是不同的数据结构。对象是一组无序的键值对集合，而数组则是一个有序的元素集合。不过，你可以根据需求，通过几种方式将对象的某些部分或全部转换成数组。

### 1. 使用`Object.keys()`, `Object.values()`, 或 `Object.entries()`

- **`Object.keys(obj)`**：返回一个由给定对象的自身属性的键组成的数组，数组中属性键的排列顺序和使用 `for...in` 循环遍历该对象时返回的顺序一致（两者的主要区别是 `for...in` 循环还会枚举其原型链上的属性）。
- **`Object.values(obj)`**：返回一个由给定对象自身的所有可枚举属性值的数组，值的排列与使用 `for...in` 循环遍历该对象时返回的属性值排列顺序一致（区别在于 `for...in` 循环还会枚举原型链中的属性）。
- **`Object.entries(obj)`**：返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 `for...in` 循环遍历该对象时返回的顺序一致（同样，`for...in` 循环还会枚举原型链中的属性）。

#### 示例

```javascript
const obj = { a: 1, b: 2, c: 3 };  
  
console.log(Object.keys(obj)); // ['a', 'b', 'c']  
console.log(Object.values(obj)); // [1, 2, 3]  
console.log(Object.entries(obj)); // [['a', 1], ['b', 2], ['c', 3]]
```

### 2. 使用`for...in`循环或`Object.keys()`结合`map()`

如果你想要对对象的值进行某种转换后再放入数组，可以结合使用`Object.keys()`（或`Object.values()`，如果你只需要值）和`map()`方法。

#### 示例：将对象的值加倍后存入数组

```javascript
const obj = { a: 1, b: 2, c: 3 };  
  
// 使用 Object.values() 和 map()  
const doubledValues = Object.values(obj).map(value => value * 2);  
console.log(doubledValues); // [2, 4, 6]  
  
// 如果你想要键值对，可以这样做：  
const doubledEntries = Object.entries(obj).map(([key, value]) => [key, value * 2]);  
console.log(doubledEntries); // [['a', 2], ['b', 4], ['c', 6]]
```

### 3. 使用扩展运算符（`...`）和`Object.values()`

在需要快速将对象的值转换为数组且不需要额外处理时，可以使用扩展运算符和`Object.values()`。

#### 示例

```javascript
const obj = { a: 1, b: 2, c: 3 };  
  
const valuesArray = [...Object.values(obj)];  
console.log(valuesArray); // [1, 2, 3]
```

注意，扩展运算符在这里实际上是多余的，因为`Object.values()`已经返回了一个数组。但如果你正在处理一个需要展开操作的更复杂的表达式，它可能会很有用。

总之，将对象转换为数组通常涉及到提取对象的键、值或键值对，并根据需要进行进一步的处理。

## 3 为什么for in循环里再判断一次hasOwnProperty

在JavaScript中，使用`for...in`循环遍历对象的属性时，有一个常见的做法是在循环体内再次使用`hasOwnProperty`方法来检查属性是否真的是该对象自身的属性，而不是继承自原型链上的属性。这是因为`for...in`循环会枚举对象自身的所有可枚举属性，以及对象在其原型链上继承的可枚举属性。

### 为什么要这么做？

1. **避免原型链上的属性干扰**：如果你的对象继承自某个原型，并且原型上定义了可枚举的属性，那么这些属性也会被`for...in`循环遍历到。这可能会导致你的代码逻辑出现不期望的行为，特别是当你只想处理对象自身的属性时。
2. **增强代码的健壮性和可控性**：通过使用`hasOwnProperty`方法，你可以明确地区分哪些属性是对象自身的，哪些是继承自原型的。这有助于你编写更加健壮和可控的代码，特别是在处理复杂对象或不确定其原型链的对象时。

### 示例

```javascript
function Person(name) {  
    this.name = name;  
}  
  
Person.prototype.sayHello = function() {  
    console.log('Hello, my name is ' + this.name);  
};  
  
const person = new Person('Alice');  
  
// 使用for...in循环遍历person对象的属性  
for (let prop in person) {  
    // 检查prop是否是person对象自身的属性  
    if (person.hasOwnProperty(prop)) {  
        console.log(prop); // 只会输出 'name'，因为'sayHello'是继承自原型的  
    }  
}  
  
// 如果不使用hasOwnProperty，则会输出'name'和'sayHello'
```

在这个例子中，如果不使用`hasOwnProperty`，`for...in`循环会输出`name`和`sayHello`两个属性。但是，通过`hasOwnProperty`的检查，我们确保了只有`person`对象自身的属性`name`被输出，而继承自原型的`sayHello`方法则被忽略了。

### 结论

因此，在`for...in`循环中使用`hasOwnProperty`是一种最佳实践，它可以帮助你避免不必要的原型链属性干扰，并让你的代码更加健壮和可控。

## 4 手写实现promise

## 5 手写实现防抖节流

## 6 说一下什么是异步

## 7 说一下promise

## 8 ECharts的具体配置

## 9 怎么封装Axios

## 10 怎么解决跨域

## 11 js中什么值可以转为false

## 12 vue3与vue2的优缺点

## 13 说一下MVVM模型

## 14 怎么取消div中image的默认样式

## 15 怎么实现元素居中

## 16 了解react吗 和vue有什么区别

## 17 反问 公司技术栈

# 北京 中科星图维天信 一面 2024-06-12 15min

## 1 项目怎么做的多端适配

## 2 vue里面常用的生命周期使用场景

## 3 怎么获取路由上的参数

## 4 js中常用的数组方法

## 5 forEach和map的区别

## 6 树形结构转数组结构

## 7 正则 过滤%<>等特殊字符

## 8 说一下项目的业务逻辑

## 9 ECharts怎么初始化图表

## 10 CSS 三栏 自动撑满中间元素

## 11 反问 公司的技术栈





